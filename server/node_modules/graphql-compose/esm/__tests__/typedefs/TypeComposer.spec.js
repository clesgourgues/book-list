"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var TypeComposer_1 = require("../../TypeComposer"); // Person from this schemaComposer gets the context defined for that schemaComposer


var mock_typedefs_1 = require("./mock-typedefs"); // I understand the schemaComposers are different, here is just for demos
// create from default schemaComposer uses the context type passed in
// TSource Person, TContext Context


var PersonTC = TypeComposer_1.TypeComposer.create({
  name: 'Person',
  fields: {
    name: 'String',
    nickName: 'String',
    age: 'Int'
  }
}); // TSource Art, TContext Context

var ArtTC = mock_typedefs_1.schemaComposerWithContext.getOrCreateTC('Art'); // TSource any, TContext any

var PostTC = TypeComposer_1.TypeComposer.create('Post'); // ****************************
// Resolvers
//
// overloads works quite well when describing the typedefs separate from implementations ;)
// so we might be having issues with the flow types as it comes with implementation
// If we ditch overloads, then user may need to always specify any if he doesn't want to specify source type
// works for no Type passed and for Person
// ****************************
// TC.getResolver()
// should be without errors! By default in resolvers source should be `any` even if provided TypeComposer.create<Person, Context>

PersonTC.getResolver('findOne').wrapResolve(function (next) {
  return function (rp) {
    rp.source.name = 5; // source any

    rp.source.age = 'string';
    return next(rp);
  };
});
mock_typedefs_1.schemaComposerWithContext.Query.addFields({
  user: PersonTC.getResolver('findOne').wrapResolve(function (next) {
    return function (rp) {
      if (rp.source) {
        rp.source.name = 5; // source any
        // rp.source.age = 'string'; // <----- here must be an error

        rp.source.age = 4;
      }

      return next(rp);
    };
  })
}); // TResolverSource is Person or you may specify

PersonTC.getResolver('findOne').wrapResolve(function (next) {
  return function (rp) {
    // rp.source.name = 5;  // source Person
    // rp.source.age = 'string';
    // source Person | undefined  as a result of Partial<ResolveParams...
    if (rp.source) {
      rp.source.name = 2; // <---- for backward compatibility for TS users, here should be mo errors (by default source: any)

      rp.source.age = 5;
    }

    return next(rp);
  };
}); // TC.addResolver()
// add resolver with no type passed in

PersonTC.addResolver({
  // <---------------- by default resolver has `source: any` an it can not be defined explicitly like it was
  resolve: function resolve(_a) {
    var source = _a.source,
        context = _a.context; // check availability

    if (source && context) {
      source.age = 2;
      source.name = 2; // <---- should not be error

      if (context.uid !== source.uid) {// do something if not the current user ...
      }
    }
  }
}); // add resolver with a source type
// <<<------ here I change Person on something basic GenericUID. Let assume that from GenericUID extended all other models, which will use this resolver.

PersonTC.addResolver({
  // <--- this is ok, if we want to provide really Basic/Global/Generic interface, which will be implemented in several types/models. And then to these types we will add current resolver.
  resolve: function resolve(_a) {
    var source = _a.source,
        context = _a.context; // check availability

    if (source && context) {
      if (context.uid !== source.uid) {// do something if not the current user ...
      }
    }
  }
}); // wrapResolverResolve

PersonTC.wrapResolverResolve('findMany', function (next) {
  return function (rp) {
    rp.source.name = 5; // source any

    rp.source.age = 'string';
    return next(rp);
  };
});
PersonTC.wrapResolverResolve('findMany', function (next) {
  return function (rp) {
    // rp.source.name = 5;  // source Person
    // rp.source.age = 'string';
    // source Person | undefined  as a result of Partial<ResolveParams...
    if (rp.source) {
      rp.source.name = 'string';
      rp.source.age = 5;
    }

    return next(rp);
  };
}); // ****************************
// Fields
// No Overloads created for fields
// ****************************

PersonTC.getFieldTC('deep') // <----- no matter what type you provide here, it should not affect on rp.source below
.getResolver('findOne').wrapResolve(function (next) {
  return function (rp) {
    // <----- provide type here, if you want to check rp.source
    // check source and context because they are defined as Partial<ResolveParams...
    if (rp.source && rp.context) {
      rp.source.deep1 = 'string';
      rp.context.uid = 'string'; // passes
    }
  };
});
PersonTC.getFieldTC('deep') // <-------------- this case should not have errors
.getResolver('findOne').wrapResolve(function (next) {
  return function (rp) {
    // no checking of rp.source as it is any, but we check context as it is inherited
    rp.source.deep1 = 5; // passes

    rp.source.deep1 = 'ssas'; // passes
    // not checked errors, rp may be undefined
    // rp.context... // fails

    if (rp.context) {
      // rp.context.uid = 5;   // fails
      rp.context.uid = 'string'; // passes
    }
  };
}); // adding new field to graphql type, its fieldConfig.resolve method should have TSource type

PersonTC.addFields({
  ageIn2030: {
    // test Thunk
    type: function type() {
      return TypeComposer_1.TypeComposer.create({
        name: 'deepAge',
        fields: {
          age: {
            type: 'Int',
            // test composeFieldConfig<TSource = Person ...
            resolve: function resolve(source, args, context) {
              source.name = 'string'; // source.name = 55; <-- errors
            }
          }
        }
      });
    },
    resolve: function resolve(source, args, context) {
      // if you don't provide other args, typescript resolves source as any
      return source.age + 12;
    }
  }
}); // **************************
// Relations
//
// This particular case has been a bit of a problem, that is before i did the changes
// resolver was always conflicting with the invoking TC
// **************************

ArtTC.addRelation('extends', {
  resolver: PersonTC.getResolver('findById'),
  prepareArgs: {
    _id: function _id(source) {
      return source.personId;
    }
  },
  projection: {
    personId: true
  }
}); // in resolvers

PersonTC.addResolver({
  // <--- this is ok, if we want to provide really Basic/Global/Generic interface, which will be implemented in several types/models. And then to these types we will add current resolver.
  resolve: function resolve(_a) {
    var source = _a.source,
        context = _a.context,
        args = _a.args; // check availability

    if (source && context && args) {
      if (context.uid !== source.uid) {
        // args.skip = 'st';
        args.skip = 4; // do something if not the current user ...
      }
    }
  }
}); // wrapResolverResolve

PersonTC.wrapResolverResolve('findMany', function (next) {
  return function (rp) {
    rp.source.name = 5; // source any

    rp.source.age = 'string';

    if (rp.args) {
      rp.args.skip = 'string';
      rp.args.skip = 4;
    }

    return next(rp);
  };
});
PersonTC.wrapResolverResolve('findMany', function (next) {
  return function (rp) {
    // rp.source.name = 5;  // source Person
    // rp.source.age = 'string';
    // source Person | undefined  as a result of Partial<ResolveParams...
    if (rp.source && rp.args) {
      rp.source.name = 'string';
      rp.source.age = 5; // rp.args.skip = 'ss';

      rp.args.skip = 4;
    }

    return next(rp);
  };
}); // in relations

ArtTC.addRelation('extends', {
  resolver: PersonTC.getResolver('findById').wrapResolve(function (next) {
    return function (rp) {
      if (rp.args) {
        // rp.args.skip = 'hey';
        rp.args.skip = 4;
      }
    };
  }),
  prepareArgs: {
    _id: function _id(source) {
      return source.personId;
    }
  },
  projection: {
    personId: true
  }
});
ArtTC.addRelation('extends', {
  resolver: PersonTC.getResolver('findById').wrapResolve(function (next) {
    return function (rp) {
      if (rp.args) {
        // rp.args.skip = 'hey';
        rp.args.skip = 4;
      }
    };
  }),
  prepareArgs: {
    _id: function _id(source) {
      return source.personId;
    }
  },
  projection: {
    personId: true
  }
});
ArtTC.addRelation('extends', {
  type: 'Int',
  resolve: function resolve(source, args, context) {
    source.id = 33;
    args.skip = 'string';
    args.skip = 33;
    context.uid = 'string';
  }
});
ArtTC.addRelation('extends', {
  type: 'Int',
  resolve: function resolve(source, args, context) {
    source.id = 33; // args.skip = 'string';

    args.skip = 33;
    context.uid = 'string';
  }
});